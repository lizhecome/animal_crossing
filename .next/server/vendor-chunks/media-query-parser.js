"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-query-parser";
exports.ids = ["vendor-chunks/media-query-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/media-query-parser/dist/media-query-parser.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeEscape: () => (/* binding */ consumeEscape),\n/* harmony export */   consumeIdent: () => (/* binding */ consumeIdent),\n/* harmony export */   consumeIdentLike: () => (/* binding */ consumeIdentLike),\n/* harmony export */   consumeIdentUnsafe: () => (/* binding */ consumeIdentUnsafe),\n/* harmony export */   consumeNumber: () => (/* binding */ consumeNumber),\n/* harmony export */   consumeNumeric: () => (/* binding */ consumeNumeric),\n/* harmony export */   consumeString: () => (/* binding */ consumeString),\n/* harmony export */   consumeUrl: () => (/* binding */ consumeUrl),\n/* harmony export */   lexicalAnalysis: () => (/* binding */ lexicalAnalysis),\n/* harmony export */   removeWhitespace: () => (/* binding */ removeWhitespace),\n/* harmony export */   syntacticAnalysis: () => (/* binding */ syntacticAnalysis),\n/* harmony export */   toAST: () => (/* binding */ toAST),\n/* harmony export */   toUnflattenedAST: () => (/* binding */ toUnflattenedAST),\n/* harmony export */   tokenizeMediaCondition: () => (/* binding */ tokenizeMediaCondition),\n/* harmony export */   tokenizeMediaFeature: () => (/* binding */ tokenizeMediaFeature),\n/* harmony export */   tokenizeMediaQuery: () => (/* binding */ tokenizeMediaQuery),\n/* harmony export */   tokenizeRange: () => (/* binding */ tokenizeRange),\n/* harmony export */   wouldStartIdentifier: () => (/* binding */ wouldStartIdentifier)\n/* harmony export */ });\n/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nvar lexicalAnalysis = function lexicalAnalysis(str, index) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  str = str.replace(weirdNewlines, '\\n').replace(nullOrSurrogates, \"\\uFFFD\");\n  str = str.replace(commentRegex, '');\n  var tokens = [];\n\n  for (; index < str.length; index += 1) {\n    var code = str.charCodeAt(index);\n\n    if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      var code_1 = str.charCodeAt(++index);\n\n      while (code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a) {\n        code_1 = str.charCodeAt(++index);\n      }\n\n      index -= 1;\n      tokens.push({\n        type: '<whitespace-token>'\n      });\n    } else if (code === 0x0022) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0023) {\n      if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n\n        if (nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080 || nextCode >= 0x0030 && nextCode <= 0x0039 || nextCode === 0x005c && index + 2 < str.length && str.charCodeAt(index + 2) !== 0x000a) {\n          var flag = wouldStartIdentifier(str, index + 1) ? 'id' : 'unrestricted';\n          var result = consumeIdentUnsafe(str, index + 1);\n\n          if (result !== null) {\n            var _b = __read(result, 2),\n                lastIndex = _b[0],\n                value = _b[1];\n\n            tokens.push({\n              type: '<hash-token>',\n              value: value.toLowerCase(),\n              flag: flag\n            });\n            index = lastIndex;\n            continue;\n          }\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0027) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _c = __read(result, 2),\n          lastIndex = _c[0],\n          value = _c[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0028) {\n      tokens.push({\n        type: '<(-token>'\n      });\n    } else if (code === 0x0029) {\n      tokens.push({\n        type: '<)-token>'\n      });\n    } else if (code === 0x002b) {\n      var plusNumeric = consumeNumeric(str, index);\n\n      if (plusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _d = __read(plusNumeric, 2),\n            lastIndex = _d[0],\n            tokenTuple = _d[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n      }\n    } else if (code === 0x002c) {\n      tokens.push({\n        type: '<comma-token>'\n      });\n    } else if (code === 0x002d) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric !== null) {\n        var _e = __read(minusNumeric, 2),\n            lastIndex = _e[0],\n            tokenTuple = _e[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n\n      if (index + 2 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n\n        if (nextCode === 0x002d && nextNextCode === 0x003e) {\n          tokens.push({\n            type: '<CDC-token>'\n          });\n          index += 2;\n          continue;\n        }\n      }\n\n      var result = consumeIdentLike(str, index);\n\n      if (result !== null) {\n        var _f = __read(result, 3),\n            lastIndex = _f[0],\n            value = _f[1],\n            type = _f[2];\n\n        tokens.push({\n          type: type,\n          value: value\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x002e) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _g = __read(minusNumeric, 2),\n            lastIndex = _g[0],\n            tokenTuple = _g[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n    } else if (code === 0x003a) {\n      tokens.push({\n        type: '<colon-token>'\n      });\n    } else if (code === 0x003b) {\n      tokens.push({\n        type: '<semicolon-token>'\n      });\n    } else if (code === 0x003c) {\n      if (index + 3 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n        var nextNextNextCode = str.charCodeAt(index + 3);\n\n        if (nextCode === 0x0021 && nextNextCode === 0x002d && nextNextNextCode === 0x002d) {\n          tokens.push({\n            type: '<CDO-token>'\n          });\n          index += 3;\n          continue;\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0040) {\n      var result = consumeIdent(str, index + 1);\n\n      if (result !== null) {\n        var _h = __read(result, 2),\n            lastIndex = _h[0],\n            value = _h[1];\n\n        tokens.push({\n          type: '<at-keyword-token>',\n          value: value.toLowerCase()\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x005b) {\n      tokens.push({\n        type: '<[-token>'\n      });\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _j = __read(result, 2),\n          lastIndex = _j[0],\n          value = _j[1];\n\n      str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n      index -= 1;\n    } else if (code === 0x005d) {\n      tokens.push({\n        type: '<]-token>'\n      });\n    } else if (code === 0x007b) {\n      tokens.push({\n        type: '<{-token>'\n      });\n    } else if (code === 0x007d) {\n      tokens.push({\n        type: '<}-token>'\n      });\n    } else if (code >= 0x0030 && code <= 0x0039) {\n      var result = consumeNumeric(str, index);\n\n      var _k = __read(result, 2),\n          lastIndex = _k[0],\n          tokenTuple = _k[1];\n\n      if (tokenTuple[0] === '<dimension-token>') {\n        tokens.push({\n          type: '<dimension-token>',\n          value: tokenTuple[1],\n          unit: tokenTuple[2].toLowerCase(),\n          flag: 'number'\n        });\n      } else if (tokenTuple[0] === '<number-token>') {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: tokenTuple[2]\n        });\n      } else {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: 'number'\n        });\n      }\n\n      index = lastIndex;\n    } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n      var result = consumeIdentLike(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _l = __read(result, 3),\n          lastIndex = _l[0],\n          value = _l[1],\n          type = _l[2];\n\n      tokens.push({\n        type: type,\n        value: value\n      });\n      index = lastIndex;\n    } else {\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    }\n  }\n\n  tokens.push({\n    type: '<EOF-token>'\n  });\n  return tokens;\n};\nvar consumeString = function consumeString(str, index) {\n  if (str.length <= index + 1) return null;\n  var firstCode = str.charCodeAt(index);\n  var charCodes = [];\n\n  for (var i = index + 1; i < str.length; i += 1) {\n    var code = str.charCodeAt(i);\n\n    if (code === firstCode) {\n      return [i, String.fromCharCode.apply(null, charCodes)];\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, i);\n      if (result === null) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          charCode = _a[1];\n\n      charCodes.push(charCode);\n      i = lastIndex;\n    } else if (code === 0x000a) {\n      return null;\n    } else {\n      charCodes.push(code);\n    }\n  }\n\n  return null;\n};\nvar wouldStartIdentifier = function wouldStartIdentifier(str, index) {\n  if (str.length <= index) return false;\n  var code = str.charCodeAt(index);\n\n  if (code === 0x002d) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002d || nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080) {\n      return true;\n    } else if (nextCode === 0x005c) {\n      if (str.length <= index + 2) return false;\n      var nextNextCode = str.charCodeAt(index + 2);\n      return nextNextCode !== 0x000a;\n    } else {\n      return false;\n    }\n  } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n    return true;\n  } else if (code === 0x005c) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n    return nextCode !== 0x000a;\n  } else {\n    return false;\n  }\n};\nvar consumeEscape = function consumeEscape(str, index) {\n  if (str.length <= index + 1) return null;\n  if (str.charCodeAt(index) !== 0x005c) return null;\n  var code = str.charCodeAt(index + 1);\n\n  if (code === 0x000a) {\n    return null;\n  } else if (code >= 0x0030 && code <= 0x0039 || code >= 0x0041 && code <= 0x0046 || code >= 0x0061 && code <= 0x0066) {\n    var hexCharCodes = [code];\n    var min = Math.min(index + 7, str.length);\n    var i = index + 2;\n\n    for (; i < min; i += 1) {\n      var code_2 = str.charCodeAt(i);\n\n      if (code_2 >= 0x0030 && code_2 <= 0x0039 || code_2 >= 0x0041 && code_2 <= 0x0046 || code_2 >= 0x0061 && code_2 <= 0x0066) {\n        hexCharCodes.push(code_2);\n      } else {\n        break;\n      }\n    }\n\n    if (i < str.length) {\n      var code_3 = str.charCodeAt(i);\n\n      if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n        i += 1;\n      }\n    }\n\n    return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];\n  } else {\n    return [index + 1, code];\n  }\n};\nvar consumeNumeric = function consumeNumeric(str, index) {\n  var numberResult = consumeNumber(str, index);\n  if (numberResult === null) return null;\n\n  var _a = __read(numberResult, 3),\n      numberEndIndex = _a[0],\n      numberValue = _a[1],\n      numberFlag = _a[2];\n\n  var identResult = consumeIdent(str, numberEndIndex + 1);\n\n  if (identResult !== null) {\n    var _b = __read(identResult, 2),\n        identEndIndex = _b[0],\n        identValue = _b[1];\n\n    return [identEndIndex, ['<dimension-token>', numberValue, identValue]];\n  }\n\n  if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n    return [numberEndIndex + 1, ['<percentage-token>', numberValue]];\n  }\n\n  return [numberEndIndex, ['<number-token>', numberValue, numberFlag]];\n};\nvar consumeNumber = function consumeNumber(str, index) {\n  if (str.length <= index) return null;\n  var flag = 'integer';\n  var numberChars = [];\n  var firstCode = str.charCodeAt(index);\n\n  if (firstCode === 0x002b || firstCode === 0x002d) {\n    index += 1;\n    if (firstCode === 0x002d) numberChars.push(0x002d);\n  }\n\n  while (index < str.length) {\n    var code = str.charCodeAt(index);\n\n    if (code >= 0x0030 && code <= 0x0039) {\n      numberChars.push(code);\n      index += 1;\n    } else {\n      break;\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002e && nextNextCode >= 0x0030 && nextNextCode <= 0x0039) {\n      numberChars.push(nextCode, nextNextCode);\n      flag = 'number';\n      index += 2;\n\n      while (index < str.length) {\n        var code = str.charCodeAt(index);\n\n        if (code >= 0x0030 && code <= 0x0039) {\n          numberChars.push(code);\n          index += 1;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n    var nextNextNextCode = str.charCodeAt(index + 2);\n\n    if (nextCode === 0x0045 || nextCode === 0x0065) {\n      var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n\n      if (nextNextIsDigit || (nextNextCode === 0x002b || nextNextCode === 0x002d) && nextNextNextCode >= 0x0030 && nextNextNextCode <= 0x0039) {\n        flag = 'number';\n\n        if (nextNextIsDigit) {\n          numberChars.push(0x0045, nextNextCode);\n          index += 2;\n        } else if (nextNextCode === 0x002d) {\n          numberChars.push(0x0045, 0x002d, nextNextNextCode);\n          index += 3;\n        } else {\n          numberChars.push(0x0045, nextNextNextCode);\n          index += 3;\n        }\n\n        while (index < str.length) {\n          var code = str.charCodeAt(index);\n\n          if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  var numberString = String.fromCharCode.apply(null, numberChars);\n  var value = flag === 'number' ? parseFloat(numberString) : parseInt(numberString);\n  if (value === -0) value = 0;\n  return Number.isNaN(value) ? null : [index - 1, value, flag];\n};\nvar consumeIdentUnsafe = function consumeIdentUnsafe(str, index) {\n  if (str.length <= index) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_4 = _a[1];\n\n        identChars.push(code_4);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return index === 0 ? null : [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeIdent = function consumeIdent(str, index) {\n  if (str.length <= index || !wouldStartIdentifier(str, index)) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_5 = _a[1];\n\n        identChars.push(code_5);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeUrl = function consumeUrl(str, index) {\n  var code = str.charCodeAt(index);\n\n  while (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n    code = str.charCodeAt(++index);\n  }\n\n  var urlChars = [];\n  var hasFinishedWord = false;\n\n  while (index < str.length) {\n    if (code === 0x0029) {\n      return [index, String.fromCharCode.apply(null, urlChars)];\n    } else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n      return null;\n    } else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n      if (result === null || hasFinishedWord) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      urlChars.push(value);\n      index = lastIndex;\n    } else {\n      if (hasFinishedWord) return null;\n      urlChars.push(code);\n    }\n\n    code = str.charCodeAt(++index);\n  }\n\n  return null;\n};\nvar consumeIdentLike = function consumeIdentLike(str, index) {\n  var result = consumeIdent(str, index);\n  if (result === null) return null;\n\n  var _a = __read(result, 2),\n      lastIndex = _a[0],\n      value = _a[1];\n\n  if (value.toLowerCase() === 'url') {\n    if (str.length > lastIndex + 1) {\n      var nextCode = str.charCodeAt(lastIndex + 1);\n\n      if (nextCode === 0x0028) {\n        for (var offset = 2; lastIndex + offset < str.length; offset += 1) {\n          var nextNextCode = str.charCodeAt(lastIndex + offset);\n\n          if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n            return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n          } else if (nextNextCode !== 0x0009 && nextNextCode !== 0x0020 && nextNextCode !== 0x000a) {\n            var result_1 = consumeUrl(str, lastIndex + offset);\n            if (result_1 === null) return null;\n\n            var _b = __read(result_1, 2),\n                lastUrlIndex = _b[0],\n                value_1 = _b[1];\n\n            return [lastUrlIndex, value_1, '<url-token>'];\n          }\n        }\n\n        return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n      }\n    }\n  } else if (str.length > lastIndex + 1) {\n    var nextCode = str.charCodeAt(lastIndex + 1);\n\n    if (nextCode === 0x0028) {\n      return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n    }\n  }\n\n  return [lastIndex, value.toLowerCase(), '<ident-token>'];\n};\n\nvar simplifyAST = function simplifyAST(ast) {\n  for (var i = ast.length - 1; i >= 0; i--) {\n    ast[i] = simplifyMediaQuery(ast[i]);\n  }\n\n  return ast;\n};\n\nvar simplifyMediaQuery = function simplifyMediaQuery(mediaQuery) {\n  if (mediaQuery.mediaCondition === null) return mediaQuery;\n  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n\n  if (mediaCondition.operator === null && mediaCondition.children.length === 1 && 'children' in mediaCondition.children[0]) {\n    mediaCondition = mediaCondition.children[0];\n  }\n\n  return {\n    mediaPrefix: mediaQuery.mediaPrefix,\n    mediaType: mediaQuery.mediaType,\n    mediaCondition: mediaCondition\n  };\n};\n\nvar simplifyMediaCondition = function simplifyMediaCondition(mediaCondition) {\n  for (var i = mediaCondition.children.length - 1; i >= 0; i--) {\n    var unsimplifiedChild = mediaCondition.children[i];\n\n    if (!('context' in unsimplifiedChild)) {\n      var child = simplifyMediaCondition(unsimplifiedChild);\n\n      if (child.operator === null && child.children.length === 1) {\n        mediaCondition.children[i] = child.children[0];\n      } else if (child.operator === mediaCondition.operator && (child.operator === 'and' || child.operator === 'or')) {\n        var spliceArgs = [i, 1];\n\n        for (var i_1 = 0; i_1 < child.children.length; i_1++) {\n          spliceArgs.push(child.children[i_1]);\n        }\n\n        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n      }\n    }\n  }\n\n  return mediaCondition;\n};\n\nvar createError = function createError(message, err) {\n  if (err instanceof Error) {\n    return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n  } else {\n    return new Error(message.trim());\n  }\n};\n\nvar toAST = function toAST(str) {\n  return simplifyAST(toUnflattenedAST(str));\n};\nvar toUnflattenedAST = function toUnflattenedAST(str) {\n  var tokenList = lexicalAnalysis(str.trim());\n\n  if (tokenList === null) {\n    throw createError('Failed tokenizing');\n  }\n\n  var startIndex = 0;\n  var endIndex = tokenList.length - 1;\n\n  if (tokenList[0].type === '<at-keyword-token>' && tokenList[0].value === 'media') {\n    if (tokenList[1].type !== '<whitespace-token>') {\n      throw createError('Expected whitespace after media');\n    }\n\n    startIndex = 2;\n\n    for (var i = 2; i < tokenList.length - 1; i++) {\n      var token = tokenList[i];\n\n      if (token.type === '<{-token>') {\n        endIndex = i;\n        break;\n      } else if (token.type === '<semicolon-token>') {\n        throw createError(\"Expected '{' in media query but found ';'\");\n      }\n    }\n  }\n\n  tokenList = tokenList.slice(startIndex, endIndex);\n  return syntacticAnalysis(tokenList);\n};\nvar removeWhitespace = function removeWhitespace(tokenList) {\n  var newTokenList = [];\n  var before = false;\n\n  for (var i = 0; i < tokenList.length; i++) {\n    if (tokenList[i].type === '<whitespace-token>') {\n      before = true;\n\n      if (newTokenList.length > 0) {\n        newTokenList[newTokenList.length - 1].wsAfter = true;\n      }\n    } else {\n      newTokenList.push(__assign(__assign({}, tokenList[i]), {\n        wsBefore: before,\n        wsAfter: false\n      }));\n      before = false;\n    }\n  }\n\n  return newTokenList;\n};\nvar syntacticAnalysis = function syntacticAnalysis(tokenList) {\n  var e_1, _a;\n\n  var mediaQueryList = [[]];\n\n  for (var i = 0; i < tokenList.length; i++) {\n    var token = tokenList[i];\n\n    if (token.type === '<comma-token>') {\n      mediaQueryList.push([]);\n    } else {\n      mediaQueryList[mediaQueryList.length - 1].push(token);\n    }\n  }\n\n  var mediaQueries = mediaQueryList.map(removeWhitespace);\n\n  if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n    return [{\n      mediaCondition: null,\n      mediaPrefix: null,\n      mediaType: 'all'\n    }];\n  } else {\n    var mediaQueryTokens = mediaQueries.map(function (mediaQueryTokens) {\n      if (mediaQueryTokens.length === 0) {\n        return null;\n      } else {\n        return tokenizeMediaQuery(mediaQueryTokens);\n      }\n    });\n    var nonNullMediaQueryTokens = [];\n\n    try {\n      for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {\n        var mediaQueryToken = mediaQueryTokens_1_1.value;\n\n        if (mediaQueryToken !== null) {\n          nonNullMediaQueryTokens.push(mediaQueryToken);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1[\"return\"])) _a.call(mediaQueryTokens_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (nonNullMediaQueryTokens.length === 0) {\n      throw createError('No valid media queries');\n    }\n\n    return nonNullMediaQueryTokens;\n  }\n};\nvar tokenizeMediaQuery = function tokenizeMediaQuery(tokens) {\n  var firstToken = tokens[0];\n\n  if (firstToken.type === '<(-token>') {\n    try {\n      return {\n        mediaPrefix: null,\n        mediaType: 'all',\n        mediaCondition: tokenizeMediaCondition(tokens, true)\n      };\n    } catch (err) {\n      throw createError(\"Expected media condition after '('\", err);\n    }\n  } else if (firstToken.type === '<ident-token>') {\n    var mediaPrefix = null;\n    var mediaType = void 0;\n    var value = firstToken.value;\n\n    if (value === 'only' || value === 'not') {\n      mediaPrefix = value;\n    }\n\n    var firstIndex = mediaPrefix === null ? 0 : 1;\n\n    if (tokens.length <= firstIndex) {\n      throw createError(\"Expected extra token in media query\");\n    }\n\n    var firstNonUnaryToken = tokens[firstIndex];\n\n    if (firstNonUnaryToken.type === '<ident-token>') {\n      var value_1 = firstNonUnaryToken.value;\n\n      if (value_1 === 'all') {\n        mediaType = 'all';\n      } else if (value_1 === 'print' || value_1 === 'screen') {\n        mediaType = value_1;\n      } else if (value_1 === 'tty' || value_1 === 'tv' || value_1 === 'projection' || value_1 === 'handheld' || value_1 === 'braille' || value_1 === 'embossed' || value_1 === 'aural' || value_1 === 'speech') {\n        mediaPrefix = mediaPrefix === 'not' ? null : 'not';\n        mediaType = 'all';\n      } else {\n        throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n      }\n    } else if (mediaPrefix === 'not' && firstNonUnaryToken.type === '<(-token>') {\n      var tokensWithParens = [{\n        type: '<(-token>',\n        wsBefore: false,\n        wsAfter: false\n      }];\n      tokensWithParens.push.apply(tokensWithParens, tokens);\n      tokensWithParens.push({\n        type: '<)-token>',\n        wsBefore: false,\n        wsAfter: false\n      });\n\n      try {\n        return {\n          mediaPrefix: null,\n          mediaType: 'all',\n          mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n        };\n      } catch (err) {\n        throw createError(\"Expected media condition after '('\", err);\n      }\n    } else {\n      throw createError('Invalid media query');\n    }\n\n    if (firstIndex + 1 === tokens.length) {\n      return {\n        mediaPrefix: mediaPrefix,\n        mediaType: mediaType,\n        mediaCondition: null\n      };\n    } else if (firstIndex + 4 < tokens.length) {\n      var secondNonUnaryToken = tokens[firstIndex + 1];\n\n      if (secondNonUnaryToken.type === '<ident-token>' && secondNonUnaryToken.value === 'and') {\n        try {\n          return {\n            mediaPrefix: mediaPrefix,\n            mediaType: mediaType,\n            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n          };\n        } catch (err) {\n          throw createError(\"Expected media condition after 'and'\", err);\n        }\n      } else {\n        throw createError(\"Expected 'and' after media prefix\");\n      }\n    } else {\n      throw createError('Expected media condition after media prefix');\n    }\n  } else {\n    throw createError('Expected media condition or media prefix');\n  }\n};\nvar tokenizeMediaCondition = function tokenizeMediaCondition(tokens, mayContainOr, previousOperator) {\n  if (previousOperator === void 0) {\n    previousOperator = null;\n  }\n\n  if (tokens.length < 3 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media condition');\n  }\n\n  var endIndexOfFirstFeature = tokens.length - 1;\n  var maxDepth = 0;\n  var count = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (token.type === '<(-token>') {\n      count += 1;\n      maxDepth = Math.max(maxDepth, count);\n    } else if (token.type === '<)-token>') {\n      count -= 1;\n    }\n\n    if (count === 0) {\n      endIndexOfFirstFeature = i;\n      break;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error('Mismatched parens\\nInvalid media condition');\n  }\n\n  var child;\n  var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n\n  if (maxDepth === 1) {\n    child = tokenizeMediaFeature(featureTokens);\n  } else {\n    if (featureTokens[1].type === '<ident-token>' && featureTokens[1].value === 'not') {\n      child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, 'not');\n    } else {\n      child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n    }\n  }\n\n  if (endIndexOfFirstFeature === tokens.length - 1) {\n    return {\n      operator: previousOperator,\n      children: [child]\n    };\n  } else {\n    var nextToken = tokens[endIndexOfFirstFeature + 1];\n\n    if (nextToken.type !== '<ident-token>') {\n      throw new Error('Invalid operator\\nInvalid media condition');\n    } else if (previousOperator !== null && previousOperator !== nextToken.value) {\n      throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n    } else if (nextToken.value === 'or' && !mayContainOr) {\n      throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n    } else if (nextToken.value !== 'and' && nextToken.value !== 'or') {\n      throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n    }\n\n    var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n    return {\n      operator: nextToken.value,\n      children: [child].concat(siblings.children)\n    };\n  }\n};\nvar tokenizeMediaFeature = function tokenizeMediaFeature(rawTokens) {\n  if (rawTokens.length < 3 || rawTokens[0].type !== '<(-token>' || rawTokens[rawTokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media feature');\n  }\n\n  var tokens = [rawTokens[0]];\n\n  for (var i = 1; i < rawTokens.length; i++) {\n    if (i < rawTokens.length - 2) {\n      var a = rawTokens[i];\n      var b = rawTokens[i + 1];\n      var c = rawTokens[i + 2];\n\n      if (a.type === '<number-token>' && a.value > 0 && b.type === '<delim-token>' && b.value === 0x002f && c.type === '<number-token>' && c.value > 0) {\n        tokens.push({\n          type: '<ratio-token>',\n          numerator: a.value,\n          denominator: c.value,\n          wsBefore: a.wsBefore,\n          wsAfter: c.wsAfter\n        });\n        i += 2;\n        continue;\n      }\n    }\n\n    tokens.push(rawTokens[i]);\n  }\n\n  var nextToken = tokens[1];\n\n  if (nextToken.type === '<ident-token>' && tokens.length === 3) {\n    return {\n      context: 'boolean',\n      feature: nextToken.value\n    };\n  } else if (tokens.length === 5 && tokens[1].type === '<ident-token>' && tokens[2].type === '<colon-token>') {\n    var valueToken = tokens[3];\n\n    if (valueToken.type === '<number-token>' || valueToken.type === '<dimension-token>' || valueToken.type === '<ratio-token>' || valueToken.type === '<ident-token>') {\n      var feature = tokens[1].value;\n      var prefix = null;\n      var slice = feature.slice(0, 4);\n\n      if (slice === 'min-') {\n        prefix = 'min';\n        feature = feature.slice(4);\n      } else if (slice === 'max-') {\n        prefix = 'max';\n        feature = feature.slice(4);\n      }\n\n      valueToken.wsBefore;\n          valueToken.wsAfter;\n          var value = __rest(valueToken, [\"wsBefore\", \"wsAfter\"]);\n\n      return {\n        context: 'value',\n        prefix: prefix,\n        feature: feature,\n        value: value\n      };\n    }\n  } else if (tokens.length >= 5) {\n    try {\n      var range = tokenizeRange(tokens);\n      return {\n        context: 'range',\n        feature: range.featureName,\n        range: range\n      };\n    } catch (err) {\n      throw createError('Invalid media feature', err);\n    }\n  }\n\n  throw new Error('Invalid media feature');\n};\nvar tokenizeRange = function tokenizeRange(tokens) {\n  var _a, _b, _c, _d;\n\n  if (tokens.length < 5 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid range');\n  }\n\n  var range = {\n    leftToken: null,\n    leftOp: null,\n    featureName: '',\n    rightOp: null,\n    rightToken: null\n  };\n  var hasLeft = tokens[1].type === '<number-token>' || tokens[1].type === '<dimension-token>' || tokens[1].type === '<ratio-token>' || tokens[1].type === '<ident-token>' && tokens[1].value === 'infinite';\n\n  if (tokens[2].type === '<delim-token>') {\n    if (tokens[2].value === 0x003c) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<';\n      }\n    } else if (tokens[2].value === 0x003e) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>';\n      }\n    } else if (tokens[2].value === 0x003d) {\n      range[hasLeft ? 'leftOp' : 'rightOp'] = '=';\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    if (hasLeft) {\n      range.leftToken = tokens[1];\n    } else if (tokens[1].type === '<ident-token>') {\n      range.featureName = tokens[1].value;\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? 'leftOp' : 'rightOp']) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n\n    if (hasLeft) {\n      if (tokenAfterFirstOp.type === '<ident-token>') {\n        range.featureName = tokenAfterFirstOp.value;\n\n        if (tokens.length >= 7) {\n          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n          var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n\n          if (secondOpToken.type === '<delim-token>') {\n            var charCode = secondOpToken.value;\n\n            if (charCode === 0x003c) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '<=';\n              } else {\n                range.rightOp = '<';\n              }\n            } else if (charCode === 0x003e) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '>=';\n              } else {\n                range.rightOp = '>';\n              }\n            } else {\n              throw new Error('Invalid range');\n            }\n\n            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n            range.rightToken = tokenAfterSecondOp;\n          } else {\n            throw new Error('Invalid range');\n          }\n        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n          throw new Error('Invalid range');\n        }\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else {\n      range.rightToken = tokenAfterFirstOp;\n    }\n\n    var validRange = null;\n    var lt = range.leftToken,\n        leftOp = range.leftOp,\n        featureName = range.featureName,\n        rightOp = range.rightOp,\n        rt = range.rightToken;\n    var leftToken = null;\n\n    if (lt !== null) {\n      if (lt.type === '<ident-token>') {\n        var type = lt.type,\n            value = lt.value;\n\n        if (value === 'infinite') {\n          leftToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (lt.type === '<number-token>' || lt.type === '<dimension-token>' || lt.type === '<ratio-token>') {\n        lt.wsBefore;\n            lt.wsAfter;\n            var ltNoWS = __rest(lt, [\"wsBefore\", \"wsAfter\"]);\n\n        leftToken = ltNoWS;\n      }\n    }\n\n    var rightToken = null;\n\n    if (rt !== null) {\n      if (rt.type === '<ident-token>') {\n        var type = rt.type,\n            value = rt.value;\n\n        if (value === 'infinite') {\n          rightToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (rt.type === '<number-token>' || rt.type === '<dimension-token>' || rt.type === '<ratio-token>') {\n        rt.wsBefore;\n            rt.wsAfter;\n            var rtNoWS = __rest(rt, [\"wsBefore\", \"wsAfter\"]);\n\n        rightToken = rtNoWS;\n      }\n    }\n\n    if (leftToken !== null && rightToken !== null) {\n      if ((leftOp === '<' || leftOp === '<=') && (rightOp === '<' || rightOp === '<=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else if ((leftOp === '>' || leftOp === '>=') && (rightOp === '>' || rightOp === '>=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    }\n\n    return validRange;\n  } else {\n    throw new Error('Invalid range');\n  }\n};\n\n\n//# sourceMappingURL=media-query-parser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxrSEFBa0gsNEJBQTRCO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTZUO0FBQzdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5pbWFsX2Nyb3NzaW5nLy4vbm9kZV9tb2R1bGVzL21lZGlhLXF1ZXJ5LXBhcnNlci9kaXN0L21lZGlhLXF1ZXJ5LXBhcnNlci5lc20uanM/ODQxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQGxpY2Vuc2UgTWVkaWFRdWVyeVBhcnNlciAtIE1JVCBMaWNlbnNlIC0gVG9tIEdvbGRlbiAoZ2l0aHViQHRiamdvbGRlbi5jb20pICovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxuXG52YXIgd2VpcmROZXdsaW5lcyA9IC8oXFx1MDAwRHxcXHUwMDBDfFxcdTAwMERcXHUwMDBBKS9nO1xudmFyIG51bGxPclN1cnJvZ2F0ZXMgPSAvW1xcdTAwMDBcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgY29tbWVudFJlZ2V4ID0gLyhcXC9cXCopW1xcc1xcU10qPyhcXCpcXC8pL2c7XG52YXIgbGV4aWNhbEFuYWx5c2lzID0gZnVuY3Rpb24gbGV4aWNhbEFuYWx5c2lzKHN0ciwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICBpbmRleCA9IDA7XG4gIH1cblxuICBzdHIgPSBzdHIucmVwbGFjZSh3ZWlyZE5ld2xpbmVzLCAnXFxuJykucmVwbGFjZShudWxsT3JTdXJyb2dhdGVzLCBcIlxcdUZGRkRcIik7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKGNvbW1lbnRSZWdleCwgJycpO1xuICB2YXIgdG9rZW5zID0gW107XG5cbiAgZm9yICg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MDAwOSB8fCBjb2RlID09PSAweDAwMjAgfHwgY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgICB2YXIgY29kZV8xID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG5cbiAgICAgIHdoaWxlIChjb2RlXzEgPT09IDB4MDAwOSB8fCBjb2RlXzEgPT09IDB4MDAyMCB8fCBjb2RlXzEgPT09IDB4MDAwYSkge1xuICAgICAgICBjb2RlXzEgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgICAgIH1cblxuICAgICAgaW5kZXggLT0gMTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzx3aGl0ZXNwYWNlLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDIyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZVN0cmluZyhzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfYVsxXTtcblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHN0cmluZy10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjMpIHtcbiAgICAgIGlmIChpbmRleCArIDEgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwNWYgfHwgbmV4dENvZGUgPj0gMHgwMDQxICYmIG5leHRDb2RlIDw9IDB4MDA1YSB8fCBuZXh0Q29kZSA+PSAweDAwNjEgJiYgbmV4dENvZGUgPD0gMHgwMDdhIHx8IG5leHRDb2RlID49IDB4MDA4MCB8fCBuZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dENvZGUgPD0gMHgwMDM5IHx8IG5leHRDb2RlID09PSAweDAwNWMgJiYgaW5kZXggKyAyIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpICE9PSAweDAwMGEpIHtcbiAgICAgICAgICB2YXIgZmxhZyA9IHdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXggKyAxKSA/ICdpZCcgOiAndW5yZXN0cmljdGVkJztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50VW5zYWZlKHN0ciwgaW5kZXggKyAxKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IF9iWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2JbMV07XG5cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJzxoYXNoLXRva2VuPicsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBmbGFnOiBmbGFnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lU3RyaW5nKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2MgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfY1swXSxcbiAgICAgICAgICB2YWx1ZSA9IF9jWzFdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8c3RyaW5nLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyOCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPCgtdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzwpLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDJiKSB7XG4gICAgICB2YXIgcGx1c051bWVyaWMgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHBsdXNOdW1lcmljID09PSBudWxsKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2QgPSBfX3JlYWQocGx1c051bWVyaWMsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2RbMF0sXG4gICAgICAgICAgICB0b2tlblR1cGxlID0gX2RbMV07XG5cbiAgICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDJjKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8Y29tbWEtdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmQpIHtcbiAgICAgIHZhciBtaW51c051bWVyaWMgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKG1pbnVzTnVtZXJpYyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2UgPSBfX3JlYWQobWludXNOdW1lcmljLCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9lWzBdLFxuICAgICAgICAgICAgdG9rZW5UdXBsZSA9IF9lWzFdO1xuXG4gICAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDIgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuXG4gICAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDJkICYmIG5leHROZXh0Q29kZSA9PT0gMHgwMDNlKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxDREMtdG9rZW4+J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudExpa2Uoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9mID0gX19yZWFkKHJlc3VsdCwgMyksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX2ZbMV0sXG4gICAgICAgICAgICB0eXBlID0gX2ZbMl07XG5cbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmUpIHtcbiAgICAgIHZhciBtaW51c051bWVyaWMgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKG1pbnVzTnVtZXJpYyA9PT0gbnVsbCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9nID0gX19yZWFkKG1pbnVzTnVtZXJpYywgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZ1swXSxcbiAgICAgICAgICAgIHRva2VuVHVwbGUgPSBfZ1sxXTtcblxuICAgICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDNhKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8Y29sb24tdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwM2IpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxzZW1pY29sb24tdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwM2MpIHtcbiAgICAgIGlmIChpbmRleCArIDMgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuICAgICAgICB2YXIgbmV4dE5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMyk7XG5cbiAgICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwMjEgJiYgbmV4dE5leHRDb2RlID09PSAweDAwMmQgJiYgbmV4dE5leHROZXh0Q29kZSA9PT0gMHgwMDJkKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxDRE8tdG9rZW4+J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA0MCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudChzdHIsIGluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9oID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfaFswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX2hbMV07XG5cbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8YXQta2V5d29yZC10b2tlbj4nLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxbLXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9qID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2pbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfalsxXTtcblxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgc3RyLnNsaWNlKGxhc3RJbmRleCArIDEpO1xuICAgICAgaW5kZXggLT0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1ZCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPF0tdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwN2IpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzx7LXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDdkKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8fS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZU51bWVyaWMoc3RyLCBpbmRleCk7XG5cbiAgICAgIHZhciBfayA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9rWzBdLFxuICAgICAgICAgIHRva2VuVHVwbGUgPSBfa1sxXTtcblxuICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODApIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnRMaWtlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2wgPSBfX3JlYWQocmVzdWx0LCAzKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfbFswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9sWzFdLFxuICAgICAgICAgIHR5cGUgPSBfbFsyXTtcblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxkZWxpbS10b2tlbj4nLFxuICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICc8RU9GLXRva2VuPidcbiAgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59O1xudmFyIGNvbnN1bWVTdHJpbmcgPSBmdW5jdGlvbiBjb25zdW1lU3RyaW5nKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAxKSByZXR1cm4gbnVsbDtcbiAgdmFyIGZpcnN0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgdmFyIGNoYXJDb2RlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNvZGUgPT09IGZpcnN0Q29kZSkge1xuICAgICAgcmV0dXJuIFtpLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNoYXJDb2RlcyldO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgIGNoYXJDb2RlID0gX2FbMV07XG5cbiAgICAgIGNoYXJDb2Rlcy5wdXNoKGNoYXJDb2RlKTtcbiAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFyQ29kZXMucHVzaChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgd291bGRTdGFydElkZW50aWZpZXIgPSBmdW5jdGlvbiB3b3VsZFN0YXJ0SWRlbnRpZmllcihzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSByZXR1cm4gZmFsc2U7XG4gIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChjb2RlID09PSAweDAwMmQpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwMmQgfHwgbmV4dENvZGUgPT09IDB4MDA1ZiB8fCBuZXh0Q29kZSA+PSAweDAwNDEgJiYgbmV4dENvZGUgPD0gMHgwMDVhIHx8IG5leHRDb2RlID49IDB4MDA2MSAmJiBuZXh0Q29kZSA8PSAweDAwN2EgfHwgbmV4dENvZGUgPj0gMHgwMDgwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5leHRDb2RlID09PSAweDAwNWMpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMikgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG4gICAgICByZXR1cm4gbmV4dE5leHRDb2RlICE9PSAweDAwMGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVmIHx8IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDVhIHx8IGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDdhIHx8IGNvZGUgPj0gMHgwMDgwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAxKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICByZXR1cm4gbmV4dENvZGUgIT09IDB4MDAwYTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgY29uc3VtZUVzY2FwZSA9IGZ1bmN0aW9uIGNvbnN1bWVFc2NhcGUoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBudWxsO1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDAwNWMpIHJldHVybiBudWxsO1xuICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgaWYgKGNvZGUgPT09IDB4MDAwYSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5IHx8IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDQ2IHx8IGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDY2KSB7XG4gICAgdmFyIGhleENoYXJDb2RlcyA9IFtjb2RlXTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4oaW5kZXggKyA3LCBzdHIubGVuZ3RoKTtcbiAgICB2YXIgaSA9IGluZGV4ICsgMjtcblxuICAgIGZvciAoOyBpIDwgbWluOyBpICs9IDEpIHtcbiAgICAgIHZhciBjb2RlXzIgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKGNvZGVfMiA+PSAweDAwMzAgJiYgY29kZV8yIDw9IDB4MDAzOSB8fCBjb2RlXzIgPj0gMHgwMDQxICYmIGNvZGVfMiA8PSAweDAwNDYgfHwgY29kZV8yID49IDB4MDA2MSAmJiBjb2RlXzIgPD0gMHgwMDY2KSB7XG4gICAgICAgIGhleENoYXJDb2Rlcy5wdXNoKGNvZGVfMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlXzMgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKGNvZGVfMyA9PT0gMHgwMDA5IHx8IGNvZGVfMyA9PT0gMHgwMDIwIHx8IGNvZGVfMyA9PT0gMHgwMDBhKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2kgLSAxLCBwYXJzZUludChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGhleENoYXJDb2RlcyksIDE2KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtpbmRleCArIDEsIGNvZGVdO1xuICB9XG59O1xudmFyIGNvbnN1bWVOdW1lcmljID0gZnVuY3Rpb24gY29uc3VtZU51bWVyaWMoc3RyLCBpbmRleCkge1xuICB2YXIgbnVtYmVyUmVzdWx0ID0gY29uc3VtZU51bWJlcihzdHIsIGluZGV4KTtcbiAgaWYgKG51bWJlclJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIF9hID0gX19yZWFkKG51bWJlclJlc3VsdCwgMyksXG4gICAgICBudW1iZXJFbmRJbmRleCA9IF9hWzBdLFxuICAgICAgbnVtYmVyVmFsdWUgPSBfYVsxXSxcbiAgICAgIG51bWJlckZsYWcgPSBfYVsyXTtcblxuICB2YXIgaWRlbnRSZXN1bHQgPSBjb25zdW1lSWRlbnQoc3RyLCBudW1iZXJFbmRJbmRleCArIDEpO1xuXG4gIGlmIChpZGVudFJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHZhciBfYiA9IF9fcmVhZChpZGVudFJlc3VsdCwgMiksXG4gICAgICAgIGlkZW50RW5kSW5kZXggPSBfYlswXSxcbiAgICAgICAgaWRlbnRWYWx1ZSA9IF9iWzFdO1xuXG4gICAgcmV0dXJuIFtpZGVudEVuZEluZGV4LCBbJzxkaW1lbnNpb24tdG9rZW4+JywgbnVtYmVyVmFsdWUsIGlkZW50VmFsdWVdXTtcbiAgfVxuXG4gIGlmIChudW1iZXJFbmRJbmRleCArIDEgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KG51bWJlckVuZEluZGV4ICsgMSkgPT09IDB4MDAyNSkge1xuICAgIHJldHVybiBbbnVtYmVyRW5kSW5kZXggKyAxLCBbJzxwZXJjZW50YWdlLXRva2VuPicsIG51bWJlclZhbHVlXV07XG4gIH1cblxuICByZXR1cm4gW251bWJlckVuZEluZGV4LCBbJzxudW1iZXItdG9rZW4+JywgbnVtYmVyVmFsdWUsIG51bWJlckZsYWddXTtcbn07XG52YXIgY29uc3VtZU51bWJlciA9IGZ1bmN0aW9uIGNvbnN1bWVOdW1iZXIoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCkgcmV0dXJuIG51bGw7XG4gIHZhciBmbGFnID0gJ2ludGVnZXInO1xuICB2YXIgbnVtYmVyQ2hhcnMgPSBbXTtcbiAgdmFyIGZpcnN0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICBpZiAoZmlyc3RDb2RlID09PSAweDAwMmIgfHwgZmlyc3RDb2RlID09PSAweDAwMmQpIHtcbiAgICBpbmRleCArPSAxO1xuICAgIGlmIChmaXJzdENvZGUgPT09IDB4MDAyZCkgbnVtYmVyQ2hhcnMucHVzaCgweDAwMmQpO1xuICB9XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICBudW1iZXJDaGFycy5wdXNoKGNvZGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyZSAmJiBuZXh0TmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHROZXh0Q29kZSA8PSAweDAwMzkpIHtcbiAgICAgIG51bWJlckNoYXJzLnB1c2gobmV4dENvZGUsIG5leHROZXh0Q29kZSk7XG4gICAgICBmbGFnID0gJ251bWJlcic7XG4gICAgICBpbmRleCArPSAyO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIGlmIChjb2RlID49IDB4MDAzMCAmJiBjb2RlIDw9IDB4MDAzOSkge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRleCArIDEgPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgIHZhciBuZXh0TmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDQ1IHx8IG5leHRDb2RlID09PSAweDAwNjUpIHtcbiAgICAgIHZhciBuZXh0TmV4dElzRGlnaXQgPSBuZXh0TmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHROZXh0Q29kZSA8PSAweDAwMzk7XG5cbiAgICAgIGlmIChuZXh0TmV4dElzRGlnaXQgfHwgKG5leHROZXh0Q29kZSA9PT0gMHgwMDJiIHx8IG5leHROZXh0Q29kZSA9PT0gMHgwMDJkKSAmJiBuZXh0TmV4dE5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0TmV4dE5leHRDb2RlIDw9IDB4MDAzOSkge1xuICAgICAgICBmbGFnID0gJ251bWJlcic7XG5cbiAgICAgICAgaWYgKG5leHROZXh0SXNEaWdpdCkge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goMHgwMDQ1LCBuZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dE5leHRDb2RlID09PSAweDAwMmQpIHtcbiAgICAgICAgICBudW1iZXJDaGFycy5wdXNoKDB4MDA0NSwgMHgwMDJkLCBuZXh0TmV4dE5leHRDb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goMHgwMDQ1LCBuZXh0TmV4dE5leHRDb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgICAgICBudW1iZXJDaGFycy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG51bWJlclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbnVtYmVyQ2hhcnMpO1xuICB2YXIgdmFsdWUgPSBmbGFnID09PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQobnVtYmVyU3RyaW5nKSA6IHBhcnNlSW50KG51bWJlclN0cmluZyk7XG4gIGlmICh2YWx1ZSA9PT0gLTApIHZhbHVlID0gMDtcbiAgcmV0dXJuIE51bWJlci5pc05hTih2YWx1ZSkgPyBudWxsIDogW2luZGV4IC0gMSwgdmFsdWUsIGZsYWddO1xufTtcbnZhciBjb25zdW1lSWRlbnRVbnNhZmUgPSBmdW5jdGlvbiBjb25zdW1lSWRlbnRVbnNhZmUoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlkZW50Q2hhcnMgPSBbXTtcblxuICBmb3IgKHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpOyBpbmRleCA8IHN0ci5sZW5ndGg7IGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KSkge1xuICAgIGlmIChjb2RlID09PSAweDAwMmQgfHwgY29kZSA9PT0gMHgwMDVmIHx8IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDVhIHx8IGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDdhIHx8IGNvZGUgPj0gMHgwMDgwIHx8IGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICBpZGVudENoYXJzLnB1c2goY29kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVFc2NhcGUoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICAgIGNvZGVfNCA9IF9hWzFdO1xuXG4gICAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlXzQpO1xuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gaW5kZXggPT09IDAgPyBudWxsIDogW2luZGV4IC0gMSwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpZGVudENoYXJzKV07XG59O1xudmFyIGNvbnN1bWVJZGVudCA9IGZ1bmN0aW9uIGNvbnN1bWVJZGVudChzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4IHx8ICF3b3VsZFN0YXJ0SWRlbnRpZmllcihzdHIsIGluZGV4KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlkZW50Q2hhcnMgPSBbXTtcblxuICBmb3IgKHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpOyBpbmRleCA8IHN0ci5sZW5ndGg7IGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KSkge1xuICAgIGlmIChjb2RlID09PSAweDAwMmQgfHwgY29kZSA9PT0gMHgwMDVmIHx8IGNvZGUgPj0gMHgwMDQxICYmIGNvZGUgPD0gMHgwMDVhIHx8IGNvZGUgPj0gMHgwMDYxICYmIGNvZGUgPD0gMHgwMDdhIHx8IGNvZGUgPj0gMHgwMDgwIHx8IGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICBpZGVudENoYXJzLnB1c2goY29kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVFc2NhcGUoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICAgIGNvZGVfNSA9IF9hWzFdO1xuXG4gICAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlXzUpO1xuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW2luZGV4IC0gMSwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpZGVudENoYXJzKV07XG59O1xudmFyIGNvbnN1bWVVcmwgPSBmdW5jdGlvbiBjb25zdW1lVXJsKHN0ciwgaW5kZXgpIHtcbiAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgd2hpbGUgKGNvZGUgPT09IDB4MDAwOSB8fCBjb2RlID09PSAweDAwMjAgfHwgY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICB9XG5cbiAgdmFyIHVybENoYXJzID0gW107XG4gIHZhciBoYXNGaW5pc2hlZFdvcmQgPSBmYWxzZTtcblxuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyOSkge1xuICAgICAgcmV0dXJuIFtpbmRleCwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1cmxDaGFycyldO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDIyIHx8IGNvZGUgPT09IDB4MDAyNyB8fCBjb2RlID09PSAweDAwMjgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICAgIGlmICghaGFzRmluaXNoZWRXb3JkICYmIHVybENoYXJzLmxlbmd0aCAhPT0gMCkgaGFzRmluaXNoZWRXb3JkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVFc2NhcGUoc3RyLCBpbmRleCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IGhhc0ZpbmlzaGVkV29yZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2FbMV07XG5cbiAgICAgIHVybENoYXJzLnB1c2godmFsdWUpO1xuICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXNGaW5pc2hlZFdvcmQpIHJldHVybiBudWxsO1xuICAgICAgdXJsQ2hhcnMucHVzaChjb2RlKTtcbiAgICB9XG5cbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgY29uc3VtZUlkZW50TGlrZSA9IGZ1bmN0aW9uIGNvbnN1bWVJZGVudExpa2Uoc3RyLCBpbmRleCkge1xuICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50KHN0ciwgaW5kZXgpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgdmFsdWUgPSBfYVsxXTtcblxuICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3VybCcpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IGxhc3RJbmRleCArIDEpIHtcbiAgICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpO1xuXG4gICAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyOCkge1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAyOyBsYXN0SW5kZXggKyBvZmZzZXQgPCBzdHIubGVuZ3RoOyBvZmZzZXQgKz0gMSkge1xuICAgICAgICAgIHZhciBuZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChsYXN0SW5kZXggKyBvZmZzZXQpO1xuXG4gICAgICAgICAgaWYgKG5leHROZXh0Q29kZSA9PT0gMHgwMDIyIHx8IG5leHROZXh0Q29kZSA9PT0gMHgwMDI3KSB7XG4gICAgICAgICAgICByZXR1cm4gW2xhc3RJbmRleCArIDEsIHZhbHVlLnRvTG93ZXJDYXNlKCksICc8ZnVuY3Rpb24tdG9rZW4+J107XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0TmV4dENvZGUgIT09IDB4MDAwOSAmJiBuZXh0TmV4dENvZGUgIT09IDB4MDAyMCAmJiBuZXh0TmV4dENvZGUgIT09IDB4MDAwYSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gY29uc3VtZVVybChzdHIsIGxhc3RJbmRleCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0XzEgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQocmVzdWx0XzEsIDIpLFxuICAgICAgICAgICAgICAgIGxhc3RVcmxJbmRleCA9IF9iWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlXzEgPSBfYlsxXTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsYXN0VXJsSW5kZXgsIHZhbHVlXzEsICc8dXJsLXRva2VuPiddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA+IGxhc3RJbmRleCArIDEpIHtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChsYXN0SW5kZXggKyAxKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICByZXR1cm4gW2xhc3RJbmRleCArIDEsIHZhbHVlLnRvTG93ZXJDYXNlKCksICc8ZnVuY3Rpb24tdG9rZW4+J107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtsYXN0SW5kZXgsIHZhbHVlLnRvTG93ZXJDYXNlKCksICc8aWRlbnQtdG9rZW4+J107XG59O1xuXG52YXIgc2ltcGxpZnlBU1QgPSBmdW5jdGlvbiBzaW1wbGlmeUFTVChhc3QpIHtcbiAgZm9yICh2YXIgaSA9IGFzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGFzdFtpXSA9IHNpbXBsaWZ5TWVkaWFRdWVyeShhc3RbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGFzdDtcbn07XG5cbnZhciBzaW1wbGlmeU1lZGlhUXVlcnkgPSBmdW5jdGlvbiBzaW1wbGlmeU1lZGlhUXVlcnkobWVkaWFRdWVyeSkge1xuICBpZiAobWVkaWFRdWVyeS5tZWRpYUNvbmRpdGlvbiA9PT0gbnVsbCkgcmV0dXJuIG1lZGlhUXVlcnk7XG4gIHZhciBtZWRpYUNvbmRpdGlvbiA9IHNpbXBsaWZ5TWVkaWFDb25kaXRpb24obWVkaWFRdWVyeS5tZWRpYUNvbmRpdGlvbik7XG5cbiAgaWYgKG1lZGlhQ29uZGl0aW9uLm9wZXJhdG9yID09PSBudWxsICYmIG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiAnY2hpbGRyZW4nIGluIG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuWzBdKSB7XG4gICAgbWVkaWFDb25kaXRpb24gPSBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlblswXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVkaWFQcmVmaXg6IG1lZGlhUXVlcnkubWVkaWFQcmVmaXgsXG4gICAgbWVkaWFUeXBlOiBtZWRpYVF1ZXJ5Lm1lZGlhVHlwZSxcbiAgICBtZWRpYUNvbmRpdGlvbjogbWVkaWFDb25kaXRpb25cbiAgfTtcbn07XG5cbnZhciBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uID0gZnVuY3Rpb24gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbihtZWRpYUNvbmRpdGlvbikge1xuICBmb3IgKHZhciBpID0gbWVkaWFDb25kaXRpb24uY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdW5zaW1wbGlmaWVkQ2hpbGQgPSBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbltpXTtcblxuICAgIGlmICghKCdjb250ZXh0JyBpbiB1bnNpbXBsaWZpZWRDaGlsZCkpIHtcbiAgICAgIHZhciBjaGlsZCA9IHNpbXBsaWZ5TWVkaWFDb25kaXRpb24odW5zaW1wbGlmaWVkQ2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQub3BlcmF0b3IgPT09IG51bGwgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuW2ldID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLm9wZXJhdG9yID09PSBtZWRpYUNvbmRpdGlvbi5vcGVyYXRvciAmJiAoY2hpbGQub3BlcmF0b3IgPT09ICdhbmQnIHx8IGNoaWxkLm9wZXJhdG9yID09PSAnb3InKSkge1xuICAgICAgICB2YXIgc3BsaWNlQXJncyA9IFtpLCAxXTtcblxuICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgc3BsaWNlQXJncy5wdXNoKGNoaWxkLmNoaWxkcmVuW2lfMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVkaWFDb25kaXRpb24uY2hpbGRyZW4uc3BsaWNlLmFwcGx5KG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuLCBzcGxpY2VBcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVkaWFDb25kaXRpb247XG59O1xuXG52YXIgY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlwiLmNvbmNhdChlcnIubWVzc2FnZS50cmltKCksIFwiXFxuXCIpLmNvbmNhdChtZXNzYWdlLnRyaW0oKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZS50cmltKCkpO1xuICB9XG59O1xuXG52YXIgdG9BU1QgPSBmdW5jdGlvbiB0b0FTVChzdHIpIHtcbiAgcmV0dXJuIHNpbXBsaWZ5QVNUKHRvVW5mbGF0dGVuZWRBU1Qoc3RyKSk7XG59O1xudmFyIHRvVW5mbGF0dGVuZWRBU1QgPSBmdW5jdGlvbiB0b1VuZmxhdHRlbmVkQVNUKHN0cikge1xuICB2YXIgdG9rZW5MaXN0ID0gbGV4aWNhbEFuYWx5c2lzKHN0ci50cmltKCkpO1xuXG4gIGlmICh0b2tlbkxpc3QgPT09IG51bGwpIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcignRmFpbGVkIHRva2VuaXppbmcnKTtcbiAgfVxuXG4gIHZhciBzdGFydEluZGV4ID0gMDtcbiAgdmFyIGVuZEluZGV4ID0gdG9rZW5MaXN0Lmxlbmd0aCAtIDE7XG5cbiAgaWYgKHRva2VuTGlzdFswXS50eXBlID09PSAnPGF0LWtleXdvcmQtdG9rZW4+JyAmJiB0b2tlbkxpc3RbMF0udmFsdWUgPT09ICdtZWRpYScpIHtcbiAgICBpZiAodG9rZW5MaXN0WzFdLnR5cGUgIT09ICc8d2hpdGVzcGFjZS10b2tlbj4nKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgd2hpdGVzcGFjZSBhZnRlciBtZWRpYScpO1xuICAgIH1cblxuICAgIHN0YXJ0SW5kZXggPSAyO1xuXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0b2tlbkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbkxpc3RbaV07XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAnPHstdG9rZW4+Jykge1xuICAgICAgICBlbmRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnPHNlbWljb2xvbi10b2tlbj4nKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgJ3snIGluIG1lZGlhIHF1ZXJ5IGJ1dCBmb3VuZCAnOydcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9rZW5MaXN0ID0gdG9rZW5MaXN0LnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgcmV0dXJuIHN5bnRhY3RpY0FuYWx5c2lzKHRva2VuTGlzdCk7XG59O1xudmFyIHJlbW92ZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiByZW1vdmVXaGl0ZXNwYWNlKHRva2VuTGlzdCkge1xuICB2YXIgbmV3VG9rZW5MaXN0ID0gW107XG4gIHZhciBiZWZvcmUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0b2tlbkxpc3RbaV0udHlwZSA9PT0gJzx3aGl0ZXNwYWNlLXRva2VuPicpIHtcbiAgICAgIGJlZm9yZSA9IHRydWU7XG5cbiAgICAgIGlmIChuZXdUb2tlbkxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXdUb2tlbkxpc3RbbmV3VG9rZW5MaXN0Lmxlbmd0aCAtIDFdLndzQWZ0ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdUb2tlbkxpc3QucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdG9rZW5MaXN0W2ldKSwge1xuICAgICAgICB3c0JlZm9yZTogYmVmb3JlLFxuICAgICAgICB3c0FmdGVyOiBmYWxzZVxuICAgICAgfSkpO1xuICAgICAgYmVmb3JlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rva2VuTGlzdDtcbn07XG52YXIgc3ludGFjdGljQW5hbHlzaXMgPSBmdW5jdGlvbiBzeW50YWN0aWNBbmFseXNpcyh0b2tlbkxpc3QpIHtcbiAgdmFyIGVfMSwgX2E7XG5cbiAgdmFyIG1lZGlhUXVlcnlMaXN0ID0gW1tdXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2VuTGlzdFtpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnPGNvbW1hLXRva2VuPicpIHtcbiAgICAgIG1lZGlhUXVlcnlMaXN0LnB1c2goW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWRpYVF1ZXJ5TGlzdFttZWRpYVF1ZXJ5TGlzdC5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWVkaWFRdWVyaWVzID0gbWVkaWFRdWVyeUxpc3QubWFwKHJlbW92ZVdoaXRlc3BhY2UpO1xuXG4gIGlmIChtZWRpYVF1ZXJpZXMubGVuZ3RoID09PSAxICYmIG1lZGlhUXVlcmllc1swXS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIG1lZGlhQ29uZGl0aW9uOiBudWxsLFxuICAgICAgbWVkaWFQcmVmaXg6IG51bGwsXG4gICAgICBtZWRpYVR5cGU6ICdhbGwnXG4gICAgfV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1lZGlhUXVlcnlUb2tlbnMgPSBtZWRpYVF1ZXJpZXMubWFwKGZ1bmN0aW9uIChtZWRpYVF1ZXJ5VG9rZW5zKSB7XG4gICAgICBpZiAobWVkaWFRdWVyeVRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5pemVNZWRpYVF1ZXJ5KG1lZGlhUXVlcnlUb2tlbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBub25OdWxsTWVkaWFRdWVyeVRva2VucyA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIG1lZGlhUXVlcnlUb2tlbnNfMSA9IF9fdmFsdWVzKG1lZGlhUXVlcnlUb2tlbnMpLCBtZWRpYVF1ZXJ5VG9rZW5zXzFfMSA9IG1lZGlhUXVlcnlUb2tlbnNfMS5uZXh0KCk7ICFtZWRpYVF1ZXJ5VG9rZW5zXzFfMS5kb25lOyBtZWRpYVF1ZXJ5VG9rZW5zXzFfMSA9IG1lZGlhUXVlcnlUb2tlbnNfMS5uZXh0KCkpIHtcbiAgICAgICAgdmFyIG1lZGlhUXVlcnlUb2tlbiA9IG1lZGlhUXVlcnlUb2tlbnNfMV8xLnZhbHVlO1xuXG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5VG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICBub25OdWxsTWVkaWFRdWVyeVRva2Vucy5wdXNoKG1lZGlhUXVlcnlUb2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0ge1xuICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5VG9rZW5zXzFfMSAmJiAhbWVkaWFRdWVyeVRva2Vuc18xXzEuZG9uZSAmJiAoX2EgPSBtZWRpYVF1ZXJ5VG9rZW5zXzFbXCJyZXR1cm5cIl0pKSBfYS5jYWxsKG1lZGlhUXVlcnlUb2tlbnNfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ05vIHZhbGlkIG1lZGlhIHF1ZXJpZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9uTnVsbE1lZGlhUXVlcnlUb2tlbnM7XG4gIH1cbn07XG52YXIgdG9rZW5pemVNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gdG9rZW5pemVNZWRpYVF1ZXJ5KHRva2Vucykge1xuICB2YXIgZmlyc3RUb2tlbiA9IHRva2Vuc1swXTtcblxuICBpZiAoZmlyc3RUb2tlbi50eXBlID09PSAnPCgtdG9rZW4+Jykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWRpYVByZWZpeDogbnVsbCxcbiAgICAgICAgbWVkaWFUeXBlOiAnYWxsJyxcbiAgICAgICAgbWVkaWFDb25kaXRpb246IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zLCB0cnVlKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyICcoJ1wiLCBlcnIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmaXJzdFRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgIHZhciBtZWRpYVByZWZpeCA9IG51bGw7XG4gICAgdmFyIG1lZGlhVHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgdmFsdWUgPSBmaXJzdFRva2VuLnZhbHVlO1xuXG4gICAgaWYgKHZhbHVlID09PSAnb25seScgfHwgdmFsdWUgPT09ICdub3QnKSB7XG4gICAgICBtZWRpYVByZWZpeCA9IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdEluZGV4ID0gbWVkaWFQcmVmaXggPT09IG51bGwgPyAwIDogMTtcblxuICAgIGlmICh0b2tlbnMubGVuZ3RoIDw9IGZpcnN0SW5kZXgpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgZXh0cmEgdG9rZW4gaW4gbWVkaWEgcXVlcnlcIik7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Tm9uVW5hcnlUb2tlbiA9IHRva2Vuc1tmaXJzdEluZGV4XTtcblxuICAgIGlmIChmaXJzdE5vblVuYXJ5VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICB2YXIgdmFsdWVfMSA9IGZpcnN0Tm9uVW5hcnlUb2tlbi52YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlXzEgPT09ICdhbGwnKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9ICdhbGwnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZV8xID09PSAncHJpbnQnIHx8IHZhbHVlXzEgPT09ICdzY3JlZW4nKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9IHZhbHVlXzE7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlXzEgPT09ICd0dHknIHx8IHZhbHVlXzEgPT09ICd0dicgfHwgdmFsdWVfMSA9PT0gJ3Byb2plY3Rpb24nIHx8IHZhbHVlXzEgPT09ICdoYW5kaGVsZCcgfHwgdmFsdWVfMSA9PT0gJ2JyYWlsbGUnIHx8IHZhbHVlXzEgPT09ICdlbWJvc3NlZCcgfHwgdmFsdWVfMSA9PT0gJ2F1cmFsJyB8fCB2YWx1ZV8xID09PSAnc3BlZWNoJykge1xuICAgICAgICBtZWRpYVByZWZpeCA9IG1lZGlhUHJlZml4ID09PSAnbm90JyA/IG51bGwgOiAnbm90JztcbiAgICAgICAgbWVkaWFUeXBlID0gJ2FsbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIlVua25vd24gaWRlbnQgJ1wiLmNvbmNhdCh2YWx1ZV8xLCBcIicgaW4gbWVkaWEgcXVlcnlcIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVkaWFQcmVmaXggPT09ICdub3QnICYmIGZpcnN0Tm9uVW5hcnlUb2tlbi50eXBlID09PSAnPCgtdG9rZW4+Jykge1xuICAgICAgdmFyIHRva2Vuc1dpdGhQYXJlbnMgPSBbe1xuICAgICAgICB0eXBlOiAnPCgtdG9rZW4+JyxcbiAgICAgICAgd3NCZWZvcmU6IGZhbHNlLFxuICAgICAgICB3c0FmdGVyOiBmYWxzZVxuICAgICAgfV07XG4gICAgICB0b2tlbnNXaXRoUGFyZW5zLnB1c2guYXBwbHkodG9rZW5zV2l0aFBhcmVucywgdG9rZW5zKTtcbiAgICAgIHRva2Vuc1dpdGhQYXJlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8KS10b2tlbj4nLFxuICAgICAgICB3c0JlZm9yZTogZmFsc2UsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZWRpYVByZWZpeDogbnVsbCxcbiAgICAgICAgICBtZWRpYVR5cGU6ICdhbGwnLFxuICAgICAgICAgIG1lZGlhQ29uZGl0aW9uOiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vuc1dpdGhQYXJlbnMsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgJygnXCIsIGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdJbnZhbGlkIG1lZGlhIHF1ZXJ5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0SW5kZXggKyAxID09PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWRpYVByZWZpeDogbWVkaWFQcmVmaXgsXG4gICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlLFxuICAgICAgICBtZWRpYUNvbmRpdGlvbjogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0SW5kZXggKyA0IDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgdmFyIHNlY29uZE5vblVuYXJ5VG9rZW4gPSB0b2tlbnNbZmlyc3RJbmRleCArIDFdO1xuXG4gICAgICBpZiAoc2Vjb25kTm9uVW5hcnlUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgc2Vjb25kTm9uVW5hcnlUb2tlbi52YWx1ZSA9PT0gJ2FuZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVkaWFQcmVmaXg6IG1lZGlhUHJlZml4LFxuICAgICAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUsXG4gICAgICAgICAgICBtZWRpYUNvbmRpdGlvbjogdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMuc2xpY2UoZmlyc3RJbmRleCArIDIpLCBmYWxzZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciAnYW5kJ1wiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkICdhbmQnIGFmdGVyIG1lZGlhIHByZWZpeFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0V4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciBtZWRpYSBwcmVmaXgnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0V4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBvciBtZWRpYSBwcmVmaXgnKTtcbiAgfVxufTtcbnZhciB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uID0gZnVuY3Rpb24gdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMsIG1heUNvbnRhaW5PciwgcHJldmlvdXNPcGVyYXRvcikge1xuICBpZiAocHJldmlvdXNPcGVyYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmlvdXNPcGVyYXRvciA9IG51bGw7XG4gIH1cblxuICBpZiAodG9rZW5zLmxlbmd0aCA8IDMgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICc8KC10b2tlbj4nIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gJzwpLXRva2VuPicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gIH1cblxuICB2YXIgZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSA9IHRva2Vucy5sZW5ndGggLSAxO1xuICB2YXIgbWF4RGVwdGggPSAwO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgY291bnQpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJzwpLXRva2VuPicpIHtcbiAgICAgIGNvdW50IC09IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICBlbmRJbmRleE9mRmlyc3RGZWF0dXJlID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb3VudCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hlZCBwYXJlbnNcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvbicpO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgZmVhdHVyZVRva2VucyA9IHRva2Vucy5zbGljZSgwLCBlbmRJbmRleE9mRmlyc3RGZWF0dXJlICsgMSk7XG5cbiAgaWYgKG1heERlcHRoID09PSAxKSB7XG4gICAgY2hpbGQgPSB0b2tlbml6ZU1lZGlhRmVhdHVyZShmZWF0dXJlVG9rZW5zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZmVhdHVyZVRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgZmVhdHVyZVRva2Vuc1sxXS52YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIGNoaWxkID0gdG9rZW5pemVNZWRpYUNvbmRpdGlvbihmZWF0dXJlVG9rZW5zLnNsaWNlKDIsIC0xKSwgdHJ1ZSwgJ25vdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IHRva2VuaXplTWVkaWFDb25kaXRpb24oZmVhdHVyZVRva2Vucy5zbGljZSgxLCAtMSksIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmRJbmRleE9mRmlyc3RGZWF0dXJlID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRvcjogcHJldmlvdXNPcGVyYXRvcixcbiAgICAgIGNoaWxkcmVuOiBbY2hpbGRdXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dFRva2VuID0gdG9rZW5zW2VuZEluZGV4T2ZGaXJzdEZlYXR1cmUgKyAxXTtcblxuICAgIGlmIChuZXh0VG9rZW4udHlwZSAhPT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3JcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvbicpO1xuICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRvciAhPT0gbnVsbCAmJiBwcmV2aW91c09wZXJhdG9yICE9PSBuZXh0VG9rZW4udmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIi5jb25jYXQobmV4dFRva2VuLnZhbHVlLCBcIicgYW5kICdcIikuY29uY2F0KHByZXZpb3VzT3BlcmF0b3IsIFwiJyBtdXN0IG5vdCBiZSBhdCBzYW1lIGxldmVsXFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb25cIikpO1xuICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLnZhbHVlID09PSAnb3InICYmICFtYXlDb250YWluT3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgJ29yJyBhdCB0b3AgbGV2ZWwgb2YgYSBtZWRpYSBxdWVyeVxcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uXCIpO1xuICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLnZhbHVlICE9PSAnYW5kJyAmJiBuZXh0VG9rZW4udmFsdWUgIT09ICdvcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3BlcmF0b3I6ICdcIi5jb25jYXQobmV4dFRva2VuLnZhbHVlLCBcIidcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvblwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdzID0gdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMuc2xpY2UoZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSArIDIpLCBtYXlDb250YWluT3IsIG5leHRUb2tlbi52YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdG9yOiBuZXh0VG9rZW4udmFsdWUsXG4gICAgICBjaGlsZHJlbjogW2NoaWxkXS5jb25jYXQoc2libGluZ3MuY2hpbGRyZW4pXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b2tlbml6ZU1lZGlhRmVhdHVyZSA9IGZ1bmN0aW9uIHRva2VuaXplTWVkaWFGZWF0dXJlKHJhd1Rva2Vucykge1xuICBpZiAocmF3VG9rZW5zLmxlbmd0aCA8IDMgfHwgcmF3VG9rZW5zWzBdLnR5cGUgIT09ICc8KC10b2tlbj4nIHx8IHJhd1Rva2Vuc1tyYXdUb2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gJzwpLXRva2VuPicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVkaWEgZmVhdHVyZScpO1xuICB9XG5cbiAgdmFyIHRva2VucyA9IFtyYXdUb2tlbnNbMF1dO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcmF3VG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPCByYXdUb2tlbnMubGVuZ3RoIC0gMikge1xuICAgICAgdmFyIGEgPSByYXdUb2tlbnNbaV07XG4gICAgICB2YXIgYiA9IHJhd1Rva2Vuc1tpICsgMV07XG4gICAgICB2YXIgYyA9IHJhd1Rva2Vuc1tpICsgMl07XG5cbiAgICAgIGlmIChhLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgJiYgYS52YWx1ZSA+IDAgJiYgYi50eXBlID09PSAnPGRlbGltLXRva2VuPicgJiYgYi52YWx1ZSA9PT0gMHgwMDJmICYmIGMudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyAmJiBjLnZhbHVlID4gMCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxyYXRpby10b2tlbj4nLFxuICAgICAgICAgIG51bWVyYXRvcjogYS52YWx1ZSxcbiAgICAgICAgICBkZW5vbWluYXRvcjogYy52YWx1ZSxcbiAgICAgICAgICB3c0JlZm9yZTogYS53c0JlZm9yZSxcbiAgICAgICAgICB3c0FmdGVyOiBjLndzQWZ0ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gocmF3VG9rZW5zW2ldKTtcbiAgfVxuXG4gIHZhciBuZXh0VG9rZW4gPSB0b2tlbnNbMV07XG5cbiAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgdG9rZW5zLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnYm9vbGVhbicsXG4gICAgICBmZWF0dXJlOiBuZXh0VG9rZW4udmFsdWVcbiAgICB9O1xuICB9IGVsc2UgaWYgKHRva2Vucy5sZW5ndGggPT09IDUgJiYgdG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiB0b2tlbnNbMl0udHlwZSA9PT0gJzxjb2xvbi10b2tlbj4nKSB7XG4gICAgdmFyIHZhbHVlVG9rZW4gPSB0b2tlbnNbM107XG5cbiAgICBpZiAodmFsdWVUb2tlbi50eXBlID09PSAnPG51bWJlci10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCB2YWx1ZVRva2VuLnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+JyB8fCB2YWx1ZVRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgdmFyIGZlYXR1cmUgPSB0b2tlbnNbMV0udmFsdWU7XG4gICAgICB2YXIgcHJlZml4ID0gbnVsbDtcbiAgICAgIHZhciBzbGljZSA9IGZlYXR1cmUuc2xpY2UoMCwgNCk7XG5cbiAgICAgIGlmIChzbGljZSA9PT0gJ21pbi0nKSB7XG4gICAgICAgIHByZWZpeCA9ICdtaW4nO1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZS5zbGljZSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpY2UgPT09ICdtYXgtJykge1xuICAgICAgICBwcmVmaXggPSAnbWF4JztcbiAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmUuc2xpY2UoNCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlVG9rZW4ud3NCZWZvcmU7XG4gICAgICAgICAgdmFsdWVUb2tlbi53c0FmdGVyO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9fcmVzdCh2YWx1ZVRva2VuLCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiAndmFsdWUnLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0b2tlbnMubGVuZ3RoID49IDUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJhbmdlID0gdG9rZW5pemVSYW5nZSh0b2tlbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogJ3JhbmdlJyxcbiAgICAgICAgZmVhdHVyZTogcmFuZ2UuZmVhdHVyZU5hbWUsXG4gICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdJbnZhbGlkIG1lZGlhIGZlYXR1cmUnLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBmZWF0dXJlJyk7XG59O1xudmFyIHRva2VuaXplUmFuZ2UgPSBmdW5jdGlvbiB0b2tlbml6ZVJhbmdlKHRva2Vucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG5cbiAgaWYgKHRva2Vucy5sZW5ndGggPCA1IHx8IHRva2Vuc1swXS50eXBlICE9PSAnPCgtdG9rZW4+JyB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09ICc8KS10b2tlbj4nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gIH1cblxuICB2YXIgcmFuZ2UgPSB7XG4gICAgbGVmdFRva2VuOiBudWxsLFxuICAgIGxlZnRPcDogbnVsbCxcbiAgICBmZWF0dXJlTmFtZTogJycsXG4gICAgcmlnaHRPcDogbnVsbCxcbiAgICByaWdodFRva2VuOiBudWxsXG4gIH07XG4gIHZhciBoYXNMZWZ0ID0gdG9rZW5zWzFdLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgdG9rZW5zWzFdLnR5cGUgPT09ICc8ZGltZW5zaW9uLXRva2VuPicgfHwgdG9rZW5zWzFdLnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHRva2Vuc1sxXS52YWx1ZSA9PT0gJ2luZmluaXRlJztcblxuICBpZiAodG9rZW5zWzJdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+Jykge1xuICAgIGlmICh0b2tlbnNbMl0udmFsdWUgPT09IDB4MDAzYykge1xuICAgICAgaWYgKHRva2Vuc1szXS50eXBlID09PSAnPGRlbGltLXRva2VuPicgJiYgdG9rZW5zWzNdLnZhbHVlID09PSAweDAwM2QgJiYgIXRva2Vuc1szXS53c0JlZm9yZSkge1xuICAgICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJzw9JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbMl0udmFsdWUgPT09IDB4MDAzZSkge1xuICAgICAgaWYgKHRva2Vuc1szXS50eXBlID09PSAnPGRlbGltLXRva2VuPicgJiYgdG9rZW5zWzNdLnZhbHVlID09PSAweDAwM2QgJiYgIXRva2Vuc1szXS53c0JlZm9yZSkge1xuICAgICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJz49JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbMl0udmFsdWUgPT09IDB4MDAzZCkge1xuICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc9JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgaWYgKGhhc0xlZnQpIHtcbiAgICAgIHJhbmdlLmxlZnRUb2tlbiA9IHRva2Vuc1sxXTtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHJhbmdlLmZlYXR1cmVOYW1lID0gdG9rZW5zWzFdLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5JbmRleEFmdGVyRmlyc3RPcCA9IDIgKyAoKF9iID0gKF9hID0gcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgdmFyIHRva2VuQWZ0ZXJGaXJzdE9wID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3BdO1xuXG4gICAgaWYgKGhhc0xlZnQpIHtcbiAgICAgIGlmICh0b2tlbkFmdGVyRmlyc3RPcC50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgICAgcmFuZ2UuZmVhdHVyZU5hbWUgPSB0b2tlbkFmdGVyRmlyc3RPcC52YWx1ZTtcblxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+PSA3KSB7XG4gICAgICAgICAgdmFyIHNlY29uZE9wVG9rZW4gPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDFdO1xuICAgICAgICAgIHZhciBmb2xsb3dpbmdUb2tlbiA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMl07XG5cbiAgICAgICAgICBpZiAoc2Vjb25kT3BUb2tlbi50eXBlID09PSAnPGRlbGltLXRva2VuPicpIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHNlY29uZE9wVG9rZW4udmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMHgwMDNjKSB7XG4gICAgICAgICAgICAgIGlmIChmb2xsb3dpbmdUb2tlbi50eXBlID09PSAnPGRlbGltLXRva2VuPicgJiYgZm9sbG93aW5nVG9rZW4udmFsdWUgPT09IDB4MDAzZCAmJiAhZm9sbG93aW5nVG9rZW4ud3NCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5yaWdodE9wID0gJzw9JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5yaWdodE9wID0gJzwnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSAweDAwM2UpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvd2luZ1Rva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBmb2xsb3dpbmdUb2tlbi52YWx1ZSA9PT0gMHgwMDNkICYmICFmb2xsb3dpbmdUb2tlbi53c0JlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPj0nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9rZW5BZnRlclNlY29uZE9wID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAxICsgKChfZCA9IChfYyA9IHJhbmdlLnJpZ2h0T3ApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApXTtcbiAgICAgICAgICAgIHJhbmdlLnJpZ2h0VG9rZW4gPSB0b2tlbkFmdGVyU2Vjb25kT3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMiAhPT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UucmlnaHRUb2tlbiA9IHRva2VuQWZ0ZXJGaXJzdE9wO1xuICAgIH1cblxuICAgIHZhciB2YWxpZFJhbmdlID0gbnVsbDtcbiAgICB2YXIgbHQgPSByYW5nZS5sZWZ0VG9rZW4sXG4gICAgICAgIGxlZnRPcCA9IHJhbmdlLmxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWUgPSByYW5nZS5mZWF0dXJlTmFtZSxcbiAgICAgICAgcmlnaHRPcCA9IHJhbmdlLnJpZ2h0T3AsXG4gICAgICAgIHJ0ID0gcmFuZ2UucmlnaHRUb2tlbjtcbiAgICB2YXIgbGVmdFRva2VuID0gbnVsbDtcblxuICAgIGlmIChsdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGx0LnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgICB2YXIgdHlwZSA9IGx0LnR5cGUsXG4gICAgICAgICAgICB2YWx1ZSA9IGx0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2luZmluaXRlJykge1xuICAgICAgICAgIGxlZnRUb2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0LnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgbHQudHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCBsdC50eXBlID09PSAnPHJhdGlvLXRva2VuPicpIHtcbiAgICAgICAgbHQud3NCZWZvcmU7XG4gICAgICAgICAgICBsdC53c0FmdGVyO1xuICAgICAgICAgICAgdmFyIGx0Tm9XUyA9IF9fcmVzdChsdCwgW1wid3NCZWZvcmVcIiwgXCJ3c0FmdGVyXCJdKTtcblxuICAgICAgICBsZWZ0VG9rZW4gPSBsdE5vV1M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0VG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKHJ0ICE9PSBudWxsKSB7XG4gICAgICBpZiAocnQudHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICAgIHZhciB0eXBlID0gcnQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gcnQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgcmlnaHRUb2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ0LnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgcnQudHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCBydC50eXBlID09PSAnPHJhdGlvLXRva2VuPicpIHtcbiAgICAgICAgcnQud3NCZWZvcmU7XG4gICAgICAgICAgICBydC53c0FmdGVyO1xuICAgICAgICAgICAgdmFyIHJ0Tm9XUyA9IF9fcmVzdChydCwgW1wid3NCZWZvcmVcIiwgXCJ3c0FmdGVyXCJdKTtcblxuICAgICAgICByaWdodFRva2VuID0gcnROb1dTO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZWZ0VG9rZW4gIT09IG51bGwgJiYgcmlnaHRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKChsZWZ0T3AgPT09ICc8JyB8fCBsZWZ0T3AgPT09ICc8PScpICYmIChyaWdodE9wID09PSAnPCcgfHwgcmlnaHRPcCA9PT0gJzw9JykpIHtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHtcbiAgICAgICAgICBsZWZ0VG9rZW46IGxlZnRUb2tlbixcbiAgICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWUsXG4gICAgICAgICAgcmlnaHRPcDogcmlnaHRPcCxcbiAgICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChsZWZ0T3AgPT09ICc+JyB8fCBsZWZ0T3AgPT09ICc+PScpICYmIChyaWdodE9wID09PSAnPicgfHwgcmlnaHRPcCA9PT0gJz49JykpIHtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHtcbiAgICAgICAgICBsZWZ0VG9rZW46IGxlZnRUb2tlbixcbiAgICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWUsXG4gICAgICAgICAgcmlnaHRPcDogcmlnaHRPcCxcbiAgICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlZnRUb2tlbiA9PT0gbnVsbCAmJiBsZWZ0T3AgPT09IG51bGwgJiYgcmlnaHRPcCAhPT0gbnVsbCAmJiByaWdodFRva2VuICE9PSBudWxsKSB7XG4gICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICBsZWZ0VG9rZW46IGxlZnRUb2tlbixcbiAgICAgICAgbGVmdE9wOiBsZWZ0T3AsXG4gICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgcmlnaHRPcDogcmlnaHRPcCxcbiAgICAgICAgcmlnaHRUb2tlbjogcmlnaHRUb2tlblxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxlZnRUb2tlbiAhPT0gbnVsbCAmJiBsZWZ0T3AgIT09IG51bGwgJiYgcmlnaHRPcCA9PT0gbnVsbCAmJiByaWdodFRva2VuID09PSBudWxsKSB7XG4gICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICBsZWZ0VG9rZW46IGxlZnRUb2tlbixcbiAgICAgICAgbGVmdE9wOiBsZWZ0T3AsXG4gICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgcmlnaHRPcDogcmlnaHRPcCxcbiAgICAgICAgcmlnaHRUb2tlbjogcmlnaHRUb2tlblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRSYW5nZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgY29uc3VtZUVzY2FwZSwgY29uc3VtZUlkZW50LCBjb25zdW1lSWRlbnRMaWtlLCBjb25zdW1lSWRlbnRVbnNhZmUsIGNvbnN1bWVOdW1iZXIsIGNvbnN1bWVOdW1lcmljLCBjb25zdW1lU3RyaW5nLCBjb25zdW1lVXJsLCBsZXhpY2FsQW5hbHlzaXMsIHJlbW92ZVdoaXRlc3BhY2UsIHN5bnRhY3RpY0FuYWx5c2lzLCB0b0FTVCwgdG9VbmZsYXR0ZW5lZEFTVCwgdG9rZW5pemVNZWRpYUNvbmRpdGlvbiwgdG9rZW5pemVNZWRpYUZlYXR1cmUsIHRva2VuaXplTWVkaWFRdWVyeSwgdG9rZW5pemVSYW5nZSwgd291bGRTdGFydElkZW50aWZpZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lZGlhLXF1ZXJ5LXBhcnNlci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js\n");

/***/ })

};
;